===========================
探究对象的结构
1）header 对象头
	自身运行时的数据
		哈希值 GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳
	类型指针
		对象指向类的元数据的指针，并非必需
		数组这种特殊的对象，还会存储数组的长度
2）InstanceData 实例数据
	受虚拟机内存分配策略的限制，如相同长度的类型会分配在一起
	Longs/Doubles  shorts/chars  
3）Padding 对齐填充
	需要对齐填充的原因是：要求对象的起始地址必须是8个字节的整数倍


=============================
深入理解对象的访问定位
1）使用句柄
	先从引用类型定位到句柄池，然后通过句柄池来找到对象的真正地址。
2）直接指针
	从引用类型直接指向对象真正的内存区域
如果可以直接使用指针找到为何还需要句柄池？
使用句柄池的好处：
	应用地址在对象变化时是不需要修改的。
使用直接指针的好处：
	速度非常快
Hotspot使用的是直接地址的方式。


=============================
垃圾回收-概述
1）如何判定对象为垃圾对象
	引用计数法
	可达性分析法
2）如何回收
	回收策略
		标记-清除算法
		复制算法
		标记-整理算法
		分代收集算法
	垃圾回收器
		Serial
		Parnew
		Cms
		G1
3）何时回收


=============================
垃圾回收-引用计数法
在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，
计数器的值就-1。
--verbose:gc 
-XX:+PrintGCDetails


=============================
垃圾回收-可达性分析法
执行效率和功能较为强大
定义一个垃圾回收的根节点GCRoot，不可达的内存区域判定为垃圾，需要回收。
从GCRoot开始搜索，所走过的路径称为引用链。
可以作为GCRoot的对象：
	虚拟机栈
	方法区的类属性所引用的对象
	方法区中常量所引用的对象
	本地方法栈中引用的对象


=============================
垃圾回收算法-标记清除算法
使用可达性分析法和引用计数法来标记出需要清除的对象。
效率问题：效率较低。
空间问题：内存区域中会出现越来越多不连续的空间。


=============================
垃圾回收算法-复制算法
线程共享区域：
	堆
		新生代
			Eden 伊甸园 80%
			Suivivor 存活期 10% 10%
			Tenured Gen （垃圾回收比较少关注）
		老年代	
	方法区
线程独享区域：
	栈
	本地方法栈
	程序计数器
复制算法提高了垃圾回收的性能，主要针对新生代内存。


=============================
垃圾回收算法-标记整理算法
老年代内存的回收效率非常低，标记整理算法主要针对老年代内存。
标记-整理-清除


=============================
垃圾回收算法-分代收集算法
根据内存的分代选择不同的垃圾回收算法，新生代内存选择复制算法，老年代内存选择标记整理算法。


=============================
垃圾回收器-Serial收集器
1）最基本，发展最悠久
2）单线程垃圾收集器，任务程序和垃圾回收是串行的
	多线程程序 -- 1个垃圾回收线程 -- 多线程程序
3）没有线程的开销，因为内存较小，所有停顿其实很短，对很多桌面应用是非常适合的。


=============================
垃圾回收器-Parnew收集器
1）多线程垃圾收集器，任务程序和垃圾回收是串行的
	多线程程序 -- 多个垃圾回收线程 -- 多线程程序
2）有的时候性能还不如Serial收集器
3）CMS多数都搭配Parnew使用


=============================
垃圾回收器-Parallel收集器
1）Parallel Scavenge收集器
	复制算法（新生代收集器）
	多线程收集器
	达到可控制的吞吐量
		-XX:MaxGFPauseMillis 垃圾收集器最大停顿时间
			停顿时间变小，会导致回收内存变小，进而造成回收频率变大。因此要平衡选择。
		-XX:CGTimeRatio 吞吐量大小
2）吞吐量：CPU用于运行用户代码的时间与CPU消耗的总时间的比值
	吞吐量 = （执行用户代码时间）/（执行用户代码的时间 + 垃圾回收所占用的时间）
	
	
=============================
垃圾回收器-CMS收集器
Concurrent Mark Sweep 并发标记清除回收器，用在老年代内存。可以做到边运行程序，边垃圾收集。
1）工作过程
	初始标记
		仅标记GCRoot能直接关联到的对象。
	并发标记
		对初始标记的对象做进一步标记。
	重新标记
		对并发标记做修改，修改并发标记过程中，因用户程序执行所产生的。
	并发清理
		把标记的对象清理掉。
2）优点
	并发收集
	低停顿
3）缺点
	占用大量的CPU资源
	无法处理浮动垃圾
	出现Concurrent Mode Failure
CMS并不是一个完全的并发收集器，在比较耗时间的标记和清除阶段是并发的，延时虽然低，但是吞吐量还是提高不上去。


=============================
垃圾回收器-G1收集器
1）优势
	并行与并发
	分代收集
		不再分新生代和老年代，而是将内存分为一块一块的。
	空间整合
	可预测的停顿
		在减少停顿这方面比CMS强很多
2）步骤
	初始标记
	并发标记
	最终标记
	筛选回收
	

=============================
内存分配-概述
内存分配策略
	优先分配到Eden
	大对象直接分配到老年代
	长期存活的对象分配到老年代
	空间分配担保
	动态对象年龄判断


=============================
内存分配-Eden区域


=============================
内存分配-大对象直接分配到老年代
	-XX:PretenureThreshold


=============================
内存分配-长期存活的对象分配到老年代
	-XX:MaxTenuringThreshold


=============================
内存分配-空间分配担保
	虚拟机默认是启动空间分配担保的
	-XX:+HandlePromotionFailure
	

=============================
内存分配-逃逸分析与栈上分配
1）栈上分配
	Java的堆已经不是对象内存分配的唯一选择，也可以分配在栈上。
	栈上内存根据方法的执行来给对象分配空间，不需要专门的垃圾回收。
2）逃逸分析
	分析对象的作用域。如果定义在方法内部，且只在方法内部调用，就认为未发生逃逸，就可以将内存分配到栈上；
	如果在方法外部也被调用，就认为发生了逃逸。
	例：
		方法返回xx对象，发生逃逸；
		为成员属性赋值，发生逃逸；
		对象的作用于仅在当前方法中有效，没有发生逃逸；
		引用成员变量的值，发生逃逸。
	如果能只在方法体中创建对象，就尽量不要去外部引用个，这也是提高性能的一个方面。

	
=============================
虚拟机工具介绍
	命令行工具（jdk的自带的工具）
		jps
		Jstat
		Jinfo
		Jmap
		Jhat
		Jstack
	可视化工具
		jConsole


=============================
虚拟机工具-jps详解
1）Java process status
2）本地虚拟机唯一id limid local virtual machine id
3）一些相关命令
	jps
	jps -l   运行的主类全名或者jar包名称
	jps -m   运行时传入主类的参数
	jps -v   虚拟机参数
	jps -mlv


=============================
虚拟机工具-Jstat详解
主要监控虚拟机运行的一些信息，依赖于jps，首先要先知道进程号：
	类加载
	内存
	垃圾收集
	jit编译的信息
jstat  -jcutil 6692(进程号)


=============================
虚拟机工具-Jinfo详解
实时查看和调整虚拟机的各种参数
-XX:option=value


=============================
虚拟机工具-Jmap详解
-XX:+HeapDumpOnOutOfMemoryError


=============================
虚拟机工具-Jhat详解
JVM heap Analysis Tool
用的不多，虚拟机快照分析工具


=============================
虚拟机工具-Jstack详解
用于生成虚拟机当前时刻的线程快照。
线程快照是指当前虚拟机内每一个线程正在执行的方法堆栈的集合，定位线程出现长时间停顿的原因。
Thread.getAllStackTraces


=============================
可视化虚拟机工具-jConsole内存监控
jconsole命令


=============================
可视化虚拟机工具-jConsole线程监控
jconsole命令


=============================
死锁原理以及可视化虚拟机工具-jConsole线程死锁监控
两个线程同时想争夺两个资源，资源加锁，导致的死锁


=============================
VisualVM使用详解


=============================
性能调优概述
	知识
	工具
	数据
	经验


=============================
性能优化-案例1
场景：
	一个配置较高的系统，部署了一个应用。
问题：
	经常有用户反映长时间出现卡顿的现象
处理思路：
	优化SQL，因并不是某个功能慢，所以优化sql解决不了该问题
	监控CPU
	监控内存，用监控工具监控内存，发现内存的使用量是正常的，但经常发生Full GC 20-30s
解决方案：
	部署多个web容器，每个web容器的堆内存指定为4g。这样每次Full GC的速度就变快了。
	具体的做了简单的Tomcat分级，因当时在内网，用了Ngix，hash的方式。
总结经验：
	配置一个Tomcat，将堆内存设置的大性能高，还是配置多个Tomcat，将内存分别设置的小性能高？
	这个不是绝对的，大多数时候认为部署一个Tomcat性能高，但遇到大对象，触发了Full GC就会出现卡顿的现象。


=============================
性能优化-案例2
场景：
	简单数据抓取系统，抓取网站上的一些数据，分发到其它的应用。
环境：
	Windows Server 2003
	JDK 5
	2G内存
	Intel Core i3
问题：
	不定期出现内存溢出，把内存加大，也无济于事。导出堆转储快照信息，没有任何错误信息，内存监控，正常。
处理思路：
	换了机器就好了。
	一直监控捕获到了异常信息，定位到是直接内存的问题，将直接内存改大就稳定的运行了。
总结经验：
	在处理内存问题时，不要忘记还有直接内存这块区域。


=============================
性能优化-案例3
场景：
	物联网应用
环境：
	CentOS 6
	JDK7
	16G内存
	8核心CPU
问题：
	connect reset。积累大量未处理的任务，导致jvm崩溃
处理思路：
	使用消息队列来处理。
总结经验：
	当处理消息不对等的情况是，中间要加一个消息队列缓冲。


=============================
前半部分内容整体回顾
1）原理
	java虚拟机的运行时区域
		线程独占区  栈，程序计数器，本地方法栈
		线程共享区  堆，方法区
	对象的创建和回收
		垃圾对象的标记算法
			引用计数法
			可达性分析法
		垃圾收集算法
			标记清除算法
			复制算法
			标记整理算法
			分代收集算法
		垃圾收集器 serial parnew parallel cms g1
	对象内存分配原则
		对象首先在Eden分配
		大对象直接进去老年代
		长期存活的对象进入到老年代
		时间分配担保
		逃逸分析以及栈上分配
2）工具
	命令行工具
	图像化工具
3）案例


=============================
Class文件简介和发展历史
1）简介
	编译：javac jdk自带的编译工具
	执行：java
	class是由编译器编译产生的。
	Eclipse编译java，是使用的javac吗？
	class文件用二进制打开，javac肯定认识，虚拟机肯定认识，所以我们也应该能认识，根据它可以反编译成java代码。
2）发展历史


=============================
Class文件结构概述
1）Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中，中间没有添加任何分隔符，
整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。
2）当遇到超过8位字符的数据项时，则会按照高位在前的方式分割成脱多个8位字节进行存储。
3）Class文件中有两种数据类型，分别是无符号数和表。
4）Class文件结构
	魔数
	Class文件版本
	常量池
	访问标志
	类索引，父类索引，接口索引集合
	字段表集合
	方法表集合
	属性表集合


=============================
Class文件设计理念以及意义
运行在jvm之上的语言：Clojure，groovy，Jruby，JPython，Scala
面向接口编程有很多好处：1）可扩展性；2）解耦；
Java面向对象的基础，多线程等是很重要的，而框架只是作为一种技术而存在。
1）按照规范编写的代码，能被编译时认识
2）编译器将代码编译为字节码，这又是一套规范


=============================
文件结构-魔数
魔数主要用来标识文件的类型
虚拟机如果要执行字节码文件，首先要进行校验。
以魔数开头的二进制文件虚拟机才会执行。
魔数往后4个字节就是class文件的版本。


=============================
文件结构-常量池  constant_pool_count


=============================
文件结构-访问标志
标识符 public final等


=============================
文件结构-类索引
所有的类继承自object


=============================
文件结构-字段表集合
字段表用于描述接口或类中声明的变量


=============================
文件结构-方法表集合


=============================
文件结构-属性表集合


=============================
字节码指令简介
Java虚拟机的指令由一个字节长度的，代表某种特定操作含义的数字，称之为操作码，
以及跟随其后的零至多个代表此操作所需参数的操作数而构成。
操作码的长度只有1个字节，因此最大只有256个。
基于栈的指令集架构。
1）字节码格式
2）字节码指令
3）类加载的机制
4）虚拟机字节码的执行引擎


=============================
字节码与数据类型
在虚拟机指令集中，大多数的指令都包含了其操作所对应的数据类型信息
lload，fload
大多数指令是包含类型信息的
也有不包含类型信息的
	goto与类型无关
	ArrayLength操作数组类型
类型多，指令少


=============================
加载和存储指令
加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。
1）将局部变量表加载到操作数栈；
2）将一个数值从操作数栈存储到局部变量表；
3）将一个常量加载到操作数栈；
4）扩充局部变量表的访问索引的指令。


=============================
运算指令
运算或算数指令用于对两个操作数栈上的值进行某种特定的运算，并把结果存储到操作数栈顶
1）加法指令：add
2）减法指令：sub
3）乘法指令：mul
4）除法指令：div
5）取余指令：rem
6）取反指令：neg


=============================
类型转换指令
类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码
中的显示类型转换操作以及用来处理字节码指令集中数据类型相关指令无关于数据类型一一对
应的问题
宽化类型处理和窄化类型处理


=============================
对象创建与访问指令
创建类实例的指令：new
创建数组的指令：newarray anewarray multianewarray
访问类字段：getfield putfield getstatic putstatic
把数组元素加载到操作数栈的指令：beload
将操作数栈的值存储到数组元素：astore
取数组长度的指令：arraylength
检查实例类型的指令：instanceof checkcast


=============================
操作数栈管理指令
操作数栈指令用于直接操作操作数栈
将操作数栈的一个或两个元素出栈：pop pop2
复制栈顶一个或两个数值并将复制或双份复制值重新压入栈顶：dup dup2 dup_x1 dup_x2
将栈顶的两个数值替换：swap


=============================
控制转移指令
控制转移指令可以让Java虚拟机有条件或无条件的从指定的位置指令而不是控制转移指令的
下一条指令继续执行程序。可以认为控制转移指令就是在修改PC寄存器的值。
条件分支：ifeq iflt ifle ifne ifgt ifnull ifcmple
复合条件分支：tableswitch lookupswitch
无条件分支：goto goto_w jsr jsr_w ret


=============================
方法调用和转移指令
1）方法调用指令
	invokevirtual指令调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），
	这也是Java语言中最常见的方法分派方式。
	invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的
	对象，找出适合的方法进行调用。
	invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有
	方法和父类方法。
	invokestatic指令用于调用类方法（static方法）
2）方法的返回指令
	方法的调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括有ireturn
	（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn
	和areturn，另外还有一条return指令供声明为void的方法，实例初始化方法、类和接口的类
	初始化方法使用。


=============================
异常处理指令
在程序中显示抛出异常操作会由athrow指令实现，除了这种情况，还有别的异常会在其他java
虚拟机指令检测到异常状况时由虚拟机自动抛出。
原来try catch比较影响程序性能，但新的jdk下是使用Exception Table，不影响性能。


=============================
同步指令
Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用
管程（Monitor）来支持的。


=============================
类加载机制概述
1）虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、解析和初始化，最终形成
可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
2）Java虚拟机是懒加载机制。


=============================
类加载时机
加载	连接	初始化			使用	卸载
Loading	Linking	Initialization	Using	Unloading
连接包括：验证、准备、解析
不被初始化的例子：
	通过子类引用父类的静态字段，子类不会被初始化
	通过数组定义来引用类
	调用类的常量


=============================
类加载过程-加载
1）通过一个类的全限定名来获取定义此类的二进制流
2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3）在内存中生成一个代表这个类的Class对象，作为这个类的各种数据的访问入口
加载源：
	文件
		Class文件
		Jar文件
	网络
	计算生成一个二进制流
		$Proxy
	由其他文件生成
		Jsp
	数据库


=============================
类加载过程-验证
1）验证时连接的第一步，这一阶段的目的是为了确保Class文件的字节流中包含
的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
2）文件格式验证
3）元数据验证
4）字节码验证
5）符号意义验证


=============================
类加载过程-准备
1）准备阶段正式为类变量分配内存病设置变量的初始值。这些变量使用的内存都
在方法区中进行分配。


=============================
类加载过程-解析
1）解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。
2）类或者接口的解析
3）字段解析
4）类方法解析
5）接口方法解析


=============================
类加载过程-初始化
初始化是类加载的最后一步
初始化是执行<clinit()>方法的过程
到初始化阶段，才是真正执行类中定义的Java程序代码


=============================
类加载器







