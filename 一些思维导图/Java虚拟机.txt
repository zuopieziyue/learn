===========================
探究对象的结构
1）header 对象头
	自身运行时的数据
		哈希值 GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳
	类型指针
		对象指向类的元数据的指针，并非必需
		数组这种特殊的对象，还会存储数组的长度
2）InstanceData 实例数据
	受虚拟机内存分配策略的限制，如相同长度的类型会分配在一起
	Longs/Doubles  shorts/chars  
3）Padding 对齐填充
	需要对齐填充的原因是：要求对象的起始地址必须是8个字节的整数倍


=============================
深入理解对象的访问定位
1）使用句柄
	先从引用类型定位到句柄池，然后通过句柄池来找到对象的真正地址。
2）直接指针
	从引用类型直接指向对象真正的内存区域
如果可以直接使用指针找到为何还需要句柄池？
使用句柄池的好处：
	应用地址在对象变化时是不需要修改的。
使用直接指针的好处：
	速度非常快
Hotspot使用的是直接地址的方式。


=============================
垃圾回收-概述
1）如何判定对象为垃圾对象
	引用计数法
	可达性分析法
2）如何回收
	回收策略
		标记-清除算法
		复制算法
		标记-整理算法
		分代收集算法
	垃圾回收器
		Serial
		Parnew
		Cms
		G1
3）何时回收


=============================
垃圾回收-引用计数法
在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，
计数器的值就-1。
--verbose:gc 
-XX:+PrintGCDetails


=============================
垃圾回收-可达性分析法
执行效率和功能较为强大
定义一个垃圾回收的根节点GCRoot，不可达的内存区域判定为垃圾，需要回收。
从GCRoot开始搜索，所走过的路径称为引用链。
可以作为GCRoot的对象：
	虚拟机栈
	方法区的类属性所引用的对象
	方法区中常量所引用的对象
	本地方法栈中引用的对象


=============================
垃圾回收算法-标记清除算法
使用可达性分析法和引用计数法来标记出需要清除的对象。
效率问题：效率较低。
空间问题：内存区域中会出现越来越多不连续的空间。


=============================
垃圾回收算法-复制算法
线程共享区域：
	堆
		新生代
			Eden 伊甸园 80%
			Suivivor 存活期 10% 10%
			Tenured Gen （垃圾回收比较少关注）
		老年代	
	方法区
线程独享区域：
	栈
	本地方法栈
	程序计数器
复制算法提高了垃圾回收的性能，主要针对新生代内存。


=============================
垃圾回收算法-标记整理算法
老年代内存的回收效率非常低，标记整理算法主要针对老年代内存。
标记-整理-清除


=============================
垃圾回收算法-分代收集算法
根据内存的分代选择不同的垃圾回收算法，新生代内存选择复制算法，老年代内存选择标记整理算法。


=============================
垃圾回收器-Serial收集器
1）最基本，发展最悠久
2）单线程垃圾收集器，任务程序和垃圾回收是串行的
	多线程程序 -- 1个垃圾回收线程 -- 多线程程序
3）没有线程的开销，因为内存较小，所有停顿其实很短，对很多桌面应用是非常适合的。


=============================
垃圾回收器-Parnew收集器
1）多线程垃圾收集器，任务程序和垃圾回收是串行的
	多线程程序 -- 多个垃圾回收线程 -- 多线程程序
2）有的时候性能还不如Serial收集器
3）CMS多数都搭配Parnew使用


=============================
垃圾回收器-Parallel收集器
1）Parallel Scavenge收集器
	复制算法（新生代收集器）
	多线程收集器
	达到可控制的吞吐量
		-XX:MaxGFPauseMillis 垃圾收集器最大停顿时间
			停顿时间变小，会导致回收内存变小，进而造成回收频率变大。因此要平衡选择。
		-XX:CGTimeRatio 吞吐量大小
2）吞吐量：CPU用于运行用户代码的时间与CPU消耗的总时间的比值
	吞吐量 = （执行用户代码时间）/（执行用户代码的时间 + 垃圾回收所占用的时间）
	
	
=============================
垃圾回收器-CMS收集器
Concurrent Mark Sweep 并发标记清除回收器，用在老年代内存。可以做到边运行程序，边垃圾收集。
1）工作过程
	初始标记
		仅标记GCRoot能直接关联到的对象。
	并发标记
		对初始标记的对象做进一步标记。
	重新标记
		对并发标记做修改，修改并发标记过程中，因用户程序执行所产生的。
	并发清理
		把标记的对象清理掉。
2）优点
	并发收集
	低停顿
3）缺点
	占用大量的CPU资源
	无法处理浮动垃圾
	出现Concurrent Mode Failure
CMS并不是一个完全的并发收集器，在比较耗时间的标记和清除阶段是并发的，延时虽然低，但是吞吐量还是提高不上去。


=============================
垃圾回收器-G1收集器
1）优势
	并行与并发
	分代收集
		不再分新生代和老年代，而是将内存分为一块一块的。
	空间整合
	可预测的停顿
		在减少停顿这方面比CMS强很多
2）步骤
	初始标记
	并发标记
	最终标记
	筛选回收
	

=============================
内存分配-概述
内存分配策略
	优先分配到Eden
	大对象直接分配到老年代
	长期存活的对象分配到老年代
	空间分配担保
	动态对象年龄判断


=============================
内存分配-Eden区域


=============================
内存分配-大对象直接分配到老年代
	-XX:PretenureThreshold


=============================
内存分配-长期存活的对象分配到老年代
	-XX:MaxTenuringThreshold


=============================
内存分配-空间分配担保
	虚拟机默认是启动空间分配担保的
	-XX:+HandlePromotionFailure
	

=============================
内存分配-逃逸分析与栈上分配
1）栈上分配
	Java的堆已经不是对象内存分配的唯一选择，也可以分配在栈上。
	栈上内存根据方法的执行来给对象分配空间，不需要专门的垃圾回收。
2）逃逸分析
	分析对象的作用域。如果定义在方法内部，且只在方法内部调用，就认为未发生逃逸，就可以将内存分配到栈上；
	如果在方法外部也被调用，就认为发生了逃逸。
	例：
		方法返回xx对象，发生逃逸；
		为成员属性赋值，发生逃逸；
		对象的作用于仅在当前方法中有效，没有发生逃逸；
		引用成员变量的值，发生逃逸。
	如果能只在方法体中创建对象，就尽量不要去外部引用个，这也是提高性能的一个方面。

	
=============================
虚拟机工具介绍
	命令行工具（jdk的自带的工具）
		jps
		Jstat
		Jinfo
		Jmap
		Jhat
		Jstack
	可视化工具
		jConsole


=============================
虚拟机工具-jps详解
1）Java process status
2）本地虚拟机唯一id limid local virtual machine id
3）一些相关命令
	jps
	jps -l   运行的主类全名或者jar包名称
	jps -m   运行时传入主类的参数
	jps -v   虚拟机参数
	jps -mlv


=============================
虚拟机工具-Jstat详解
主要监控虚拟机运行的一些信息，依赖于jps，首先要先知道进程号：
	类加载
	内存
	垃圾收集
	jit编译的信息
jstat  -jcutil 6692(进程号)


=============================
虚拟机工具-Jinfo详解
实时查看和调整虚拟机的各种参数
-XX:option=value


=============================
虚拟机工具-Jmap详解
-XX:+HeapDumpOnOutOfMemoryError


=============================
虚拟机工具-Jhat详解
JVM heap Analysis Tool
用的不多，虚拟机快照分析工具


=============================
虚拟机工具-Jstack详解
用于生成虚拟机当前时刻的线程快照。
线程快照是指当前虚拟机内每一个线程正在执行的方法堆栈的集合，定位线程出现长时间停顿的原因。
Thread.getAllStackTraces


=============================
可视化虚拟机工具-jConsole内存监控
jconsole命令


=============================
可视化虚拟机工具-jConsole线程监控
jconsole命令


=============================
死锁原理以及可视化虚拟机工具-jConsole线程死锁监控
两个线程同时想争夺两个资源，资源加锁，导致的死锁


=============================
VisualVM使用详解


=============================
性能调优概述
	知识
	工具
	数据
	经验


=============================
性能优化-案例1
场景：
	一个配置较高的系统，部署了一个应用。
问题：
	经常有用户反映长时间出现卡顿的现象
处理思路：
	优化SQL，因并不是某个功能慢，所以优化sql解决不了该问题
	监控CPU
	监控内存，用监控工具监控内存，发现内存的使用量是正常的，但经常发生Full GC 20-30s
解决方案：
	部署多个web容器，每个web容器的堆内存指定为4g。这样每次Full GC的速度就变快了。
	具体的做了简单的Tomcat分级，因当时在内网，用了Ngix，hash的方式。
总结经验：
	配置一个Tomcat，将堆内存设置的大性能高，还是配置多个Tomcat，将内存分别设置的小性能高？
	这个不是绝对的，大多数时候认为部署一个Tomcat性能高，但遇到大对象，触发了Full GC就会出现卡顿的现象。


=============================
性能优化-案例2
场景：
	简单数据抓取系统，抓取网站上的一些数据，分发到其它的应用。
环境：
	Windows Server 2003
	JDK 5
	2G内存
	Intel Core i3
问题：
	不定期出现内存溢出，把内存加大，也无济于事。导出堆转储快照信息，没有任何错误信息，内存监控，正常。
处理思路：
	换了机器就好了。
	一直监控捕获到了异常信息，定位到是直接内存的问题，将直接内存改大就稳定的运行了。
总结经验：
	在处理内存问题时，不要忘记还有直接内存这块区域。


=============================
性能优化-案例3
场景：
	物联网应用
环境：
	CentOS 6
	JDK7
	16G内存
	8核心CPU
问题：
	connect reset。积累大量未处理的任务，导致jvm崩溃
处理思路：
	使用消息队列来处理。
总结经验：
	当处理消息不对等的情况是，中间要加一个消息队列缓冲。


=============================
前半部分内容整体回顾
1）原理
	java虚拟机的运行时区域
		线程独占区  栈，程序计数器，本地方法栈
		线程共享区  堆，方法区
	对象的创建和回收
		垃圾对象的标记算法
			引用计数法
			可达性分析法
		垃圾收集算法
			标记清除算法
			复制算法
			标记整理算法
			分代收集算法
		垃圾收集器 serial parnew parallel cms g1
	对象内存分配原则
		对象首先在Eden分配
		大对象直接进去老年代
		长期存活的对象进入到老年代
		时间分配担保
		逃逸分析以及栈上分配
2）工具
	命令行工具
	图像化工具
3）案例


=============================
Class文件简介和发展历史
1）简介
	编译：javac jdk自带的编译工具
	执行：java
	class是由编译器编译产生的。
	Eclipse编译java，是使用的javac吗？
	class文件用二进制打开，javac肯定认识，虚拟机肯定认识，所以我们也应该能认识，根据它可以反编译成java代码。
2）发展历史


=============================
Class文件结构概述
1）Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中，中间没有添加任何分隔符，
整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。
2）当遇到超过8位字符的数据项时，则会按照高位在前的方式分割成脱氨个8位字节进行存储。
3）Class文件中有两种数据类型，分别是无符号数和表。
4）Class文件结构
	魔数
	Class文件版本
	常量池
	访问标志
	类索引，父类索引，接口索引集合
	字段表集合
	方法表集合
	属性表集合


=============================
Class文件设计理念以及意义
运行在jvm之上的语言：Clojure，groovy，Jruby，JPython，Scala



