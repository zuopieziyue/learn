===========================
探究对象的结构
1）header 对象头
	自身运行时的数据
		哈希值 GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳
	类型指针
		对象指向类的元数据的指针，并非必需
		数组这种特殊的对象，还会存储数组的长度
2）InstanceData 实例数据
	受虚拟机内存分配策略的限制，如相同长度的类型会分配在一起
	Longs/Doubles  shorts/chars  
3）Padding 对齐填充
	需要对齐填充的原因是：要求对象的起始地址必须是8个字节的整数倍


=============================
深入理解对象的访问定位
1）使用句柄
	先从引用类型定位到句柄池，然后通过句柄池来找到对象的真正地址。
2）直接指针
	从引用类型直接指向对象真正的内存区域
如果可以直接使用指针找到为何还需要句柄池？
使用句柄池的好处：
	应用地址在对象变化时是不需要修改的。
使用直接指针的好处：
	速度非常快
Hotspot使用的是直接地址的方式。


=============================
垃圾回收-概述
1）如何判定对象为垃圾对象
	引用计数法
	可达性分析法
2）如何回收
	回收策略
		标记-清除算法
		复制算法
		标记-整理算法
		分代收集算法
	垃圾回收器
		Serial
		Parnew
		Cms
		G1
3）何时回收


=============================
垃圾回收-引用计数法
在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，
计数器的值就-1。
--verbose:gc 
-XX:+PrintGCDetails


=============================
垃圾回收-可达性分析法
执行效率和功能较为强大
定义一个垃圾回收的根节点GCRoot，不可达的内存区域判定为垃圾，需要回收。
从GCRoot开始搜索，所走过的路径称为引用链。
可以作为GCRoot的对象：
	虚拟机栈
	方法区的类属性所引用的对象
	方法区中常量所引用的对象
	本地方法栈中引用的对象


=============================
垃圾回收算法-标记清除算法
使用可达性分析法和引用计数法来标记出需要清除的对象。
效率问题：效率较低。
空间问题：内存区域中会出现越来越多不连续的空间。


=============================
垃圾回收算法-复制算法
线程共享区域：
	堆
		新生代
			Eden 伊甸园 80%
			Suivivor 存活期 10% 10%
			Tenured Gen （垃圾回收比较少关注）
		老年代	
	方法区
线程独享区域：
	栈
	本地方法栈
	程序计数器
复制算法提高了垃圾回收的性能，主要针对新生代内存。


=============================
垃圾回收算法-标记整理算法
老年代内存的回收效率非常低，标记整理算法主要针对老年代内存。
标记-整理-清除


=============================
垃圾回收算法-分代收集算法
根据内存的分代选择不同的垃圾回收算法，新生代内存选择复制算法，老年代内存选择标记整理算法。


=============================
垃圾回收器-Serial收集器
1）最基本，发展最悠久
2）单线程垃圾收集器，任务程序和垃圾回收是串行的
	多线程程序 -- 1个垃圾回收线程 -- 多线程程序
3）没有线程的开销，因为内存较小，所有停顿其实很短，对很多桌面应用是非常适合的。


=============================
垃圾回收器-Parnew收集器
1）多线程垃圾收集器，任务程序和垃圾回收是串行的
	多线程程序 -- 多个垃圾回收线程 -- 多线程程序
2）有的时候性能还不如Serial收集器
3）CMS多数都搭配Parnew使用


=============================
垃圾回收器-Parallel收集器
1）Parallel Scavenge收集器
	复制算法（新生代收集器）
	多线程收集器
	达到可控制的吞吐量
		-XX:MaxGFPauseMillis 垃圾收集器最大停顿时间
			停顿时间变小，会导致回收内存变小，进而造成回收频率变大。因此要平衡选择。
		-XX:CGTimeRatio 吞吐量大小
2）吞吐量：CPU用于运行用户代码的时间与CPU消耗的总时间的比值
	吞吐量 = （执行用户代码时间）/（执行用户代码的时间 + 垃圾回收所占用的时间）
	
	
=============================
垃圾回收器-CMS收集器
Concurrent Mark Sweep 并发标记清除回收器，用在老年代内存。可以做到边运行程序，边垃圾收集。
1）工作过程
	初始标记
	并发标记
	重新标记
	并发清理
2）优点
2）缺点









