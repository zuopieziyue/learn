===========================
探究对象的结构
1）header 对象头
	自身运行时的数据
		哈希值 GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳
	类型指针
		对象指向类的元数据的指针，并非必需
		数组这种特殊的对象，还会存储数组的长度
2）InstanceData 实例数据
	受虚拟机内存分配策略的限制，如相同长度的类型会分配在一起
	Longs/Doubles  shorts/chars  
3）Padding 对齐填充
	需要对齐填充的原因是：要求对象的起始地址必须是8个字节的整数倍


=============================
深入理解对象的访问定位
1）使用句柄
	先从引用类型定位到句柄池，然后通过句柄池来找到对象的真正地址。
2）直接指针
	从引用类型直接指向对象真正的内存区域
如果可以直接使用指针找到为何还需要句柄池？
使用句柄池的好处：
	应用地址在对象变化时是不需要修改的。
使用直接指针的好处：
	速度非常快
Hotspot使用的是直接地址的方式。


=============================
垃圾回收-概述
1）如何判定对象为垃圾对象
	引用计数法
	可达性分析法
2）如何回收
	回收策略
		标记-清除算法
		复制算法
		标记-整理算法
		分代收集算法
	垃圾回收器
		Serial
		Parnew
		Cms
		G1
3）何时回收


=============================
垃圾回收-引用计数法
在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1，当引用失效的时候，
计数器的值就-1。
--verbose:gc 
-XX:+PrintGCDetails


=============================
垃圾回收-可达性分析法
执行效率和功能较为强大
定义一个垃圾回收的根节点GCRoot，不可达的内存区域判定为垃圾，需要回收。
从GCRoot开始搜索，所走过的路径称为引用链。
可以作为GCRoot的对象：
	虚拟机栈
	方法区的类属性所引用的对象
	方法区中常量所引用的对象
	本地方法栈中引用的对象


=============================
垃圾回收算法-标记清除算法
使用可达性分析法和引用计数法来标记出需要清除的对象。
效率问题：效率较低。
空间问题：内存区域中会出现越来越多不连续的空间。


=============================
垃圾回收算法-复制算法
线程共享区域：
	堆
		新生代
			Eden 伊甸园 80%
			Suivivor 存活期 10% 10%
			Tenured Gen （垃圾回收比较少关注）
		老年代	
	方法区
线程独享区域：
	栈
	本地方法栈
	程序计数器
复制算法提高了垃圾回收的性能，主要针对新生代内存。


=============================
垃圾回收算法-标记整理算法
老年代内存的回收效率非常低，标记整理算法主要针对老年代内存。
标记-整理-清除


=============================
垃圾回收算法-分代收集算法
根据内存的分代选择不同的垃圾回收算法，新生代内存选择复制算法，老年代内存选择标记整理算法。


=============================
垃圾回收器-Serial收集器
1）最基本，发展最悠久
2）单线程垃圾收集器，任务程序和垃圾回收是串行的
	多线程程序 -- 1个垃圾回收线程 -- 多线程程序
3）没有线程的开销，因为内存较小，所有停顿其实很短，对很多桌面应用是非常适合的。


=============================
垃圾回收器-Parnew收集器
1）多线程垃圾收集器，任务程序和垃圾回收是串行的
	多线程程序 -- 多个垃圾回收线程 -- 多线程程序
2）有的时候性能还不如Serial收集器
3）CMS多数都搭配Parnew使用


=============================
垃圾回收器-Parallel收集器
1）Parallel Scavenge收集器
	复制算法（新生代收集器）
	多线程收集器
	达到可控制的吞吐量
		-XX:MaxGFPauseMillis 垃圾收集器最大停顿时间
			停顿时间变小，会导致回收内存变小，进而造成回收频率变大。因此要平衡选择。
		-XX:CGTimeRatio 吞吐量大小
2）吞吐量：CPU用于运行用户代码的时间与CPU消耗的总时间的比值
	吞吐量 = （执行用户代码时间）/（执行用户代码的时间 + 垃圾回收所占用的时间）
	
	
=============================
垃圾回收器-CMS收集器
Concurrent Mark Sweep 并发标记清除回收器，用在老年代内存。可以做到边运行程序，边垃圾收集。
1）工作过程
	初始标记
		仅标记GCRoot能直接关联到的对象。
	并发标记
		对初始标记的对象做进一步标记。
	重新标记
		对并发标记做修改，修改并发标记过程中，因用户程序执行所产生的。
	并发清理
		把标记的对象清理掉。
2）优点
	并发收集
	低停顿
3）缺点
	占用大量的CPU资源
	无法处理浮动垃圾
	出现Concurrent Mode Failure
CMS并不是一个完全的并发收集器，在比较耗时间的标记和清除阶段是并发的，延时虽然低，但是吞吐量还是提高不上去。


=============================
垃圾回收器-G1收集器
1）优势
	并行与并发
	分代收集
		不再分新生代和老年代，而是将内存分为一块一块的。
	空间整合
	可预测的停顿
		在减少停顿这方面比CMS强很多
2）步骤
	初始标记
	并发标记
	最终标记
	筛选回收
	

=============================
内存分配-概述
内存分配策略
	优先分配到Eden
	大对象直接分配到老年代
	长期存活的对象分配到老年代
	空间分配担保
	动态对象年龄判断


=============================
内存分配-Eden区域


=============================
内存分配-大对象直接分配到老年代
	-XX:PretenureThreshold


=============================
内存分配-长期存活的对象分配到老年代
	-XX:MaxTenuringThreshold


=============================
内存分配-空间分配担保
	虚拟机默认是启动空间分配担保的
	-XX:+HandlePromotionFailure
	

=============================
内存分配-逃逸分析与栈上分配
1）栈上分配
	Java的堆已经不是对象内存分配的唯一选择，也可以分配在栈上。
	栈上内存根据方法的执行来给对象分配空间，不需要专门的垃圾回收。
2）逃逸分析
	分析对象的作用域。如果定义在方法内部，且只在方法内部调用，就认为未发生逃逸，就可以将内存分配到栈上；
	如果在方法外部也被调用，就认为发生了逃逸。
	例：
		方法返回xx对象，发生逃逸；
		为成员属性赋值，发生逃逸；
		对象的作用于仅在当前方法中有效，没有发生逃逸；
		引用成员变量的值，发生逃逸。
	如果能只在方法体中创建对象，就尽量不要去外部引用个，这也是提高性能的一个方面。

	
=============================
虚拟机工具介绍
	命令行工具（jdk的自带的工具）
		jps
		Jstat
		Jinfo
		Jmap
		Jhat
		Jstack
	可视化工具
		jConsole


=============================
虚拟机工具-jps详解
1）Java process status
2）本地虚拟机唯一id limid local virtual machine id
3）一些相关命令
	jps
	jps -l   运行的主类全名或者jar包名称
	jps -m   运行时传入主类的参数
	jps -v   虚拟机参数
	jps -mlv


=============================
虚拟机工具-Jstat详解
主要监控虚拟机运行的一些信息，依赖于jps，首先要先知道进程号：
	类加载
	内存
	垃圾收集
	jit编译的信息
jstat  -jcutil 6692(进程号)


=============================
虚拟机工具-Jinfo详解
实时查看和调整虚拟机的各种参数
-XX:option=value


=============================
虚拟机工具-Jmap详解
-XX:+HeapDumpOnOutOfMemoryError


=============================
虚拟机工具-Jhat详解
JVM heap Analysis Tool
用的不多，虚拟机快照分析工具


=============================
虚拟机工具-Jstack详解
用于生成虚拟机当前时刻的线程快照。
线程快照是指当前虚拟机内每一个线程正在执行的方法堆栈的集合，定位线程出现长时间停顿的原因。
Thread.getAllStackTraces


=============================
可视化虚拟机工具-jConsole内存监控
jconsole命令


=============================
可视化虚拟机工具-jConsole线程监控
jconsole命令


=============================
死锁原理以及可视化虚拟机工具-jConsole线程死锁监控
两个线程同时想争夺两个资源，资源加锁，导致的死锁


=============================
VisualVM使用详解


=============================
性能调优概述
	知识
	工具
	数据
	经验



